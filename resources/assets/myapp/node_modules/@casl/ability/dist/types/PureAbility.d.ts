import { Rule } from './Rule';
import { RawRuleFrom } from './RawRule';
import { DetectSubjectType, ResolveAction, CanParameters, Abilities, Normalize, ConditionsMatcher, FieldMatcher } from './types';
export declare type Unsubscribe = () => void;
export interface AbilityOptions<A extends Abilities, Conditions> {
    /** @deprecated use "detectSubjectType" option instead */
    subjectName?: this['detectSubjectType'];
    detectSubjectType?: DetectSubjectType<Normalize<A>[1]>;
    conditionsMatcher?: ConditionsMatcher<Conditions>;
    fieldMatcher?: FieldMatcher;
    resolveAction?: ResolveAction<Normalize<A>[0]>;
}
export declare type AnyAbility = PureAbility<any, any>;
export declare type Generics<T extends AnyAbility> = T extends AnyAbility ? {
    abilities: T['_za'];
    conditions: T['_zc'];
} : never;
export declare type RuleOf<T extends AnyAbility> = Rule<Generics<T>['abilities'], Generics<T>['conditions']>;
export declare type RawRuleOf<T extends AnyAbility> = RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;
export declare type AbilityOptionsOf<T extends AnyAbility> = AbilityOptions<Generics<T>['abilities'], Generics<T>['conditions']>;
export interface AbilityEvent<T extends AnyAbility> {
    ability: T;
}
export interface UpdateEvent<T extends AnyAbility> extends AbilityEvent<T> {
    rules: RawRuleOf<T>[];
}
export declare type EventHandler<Event> = (event: Event) => void;
declare type EventsMap<T extends AnyAbility> = {
    update: UpdateEvent<T>;
    updated: UpdateEvent<T>;
};
export declare type AbilityClass<T extends AnyAbility> = new (rules?: RawRuleOf<T>[], options?: AbilityOptionsOf<T>) => T;
export declare class PureAbility<A extends Abilities = Abilities, Conditions = unknown> {
    private _hasPerFieldRules;
    private _mergedRules;
    private _events;
    private _indexedRules;
    private readonly _ruleOptions;
    readonly detectSubjectType: DetectSubjectType<Normalize<A>[1]>;
    private _rules;
    readonly rules: RawRuleFrom<A, Conditions>[];
    /** hack property type to improve inference */
    readonly _za: A;
    /** hack property type to improve inference */
    readonly _zc: Conditions;
    constructor(rules?: RawRuleFrom<A, Conditions>[], options?: AbilityOptions<A, Conditions>);
    update(rules: RawRuleFrom<A, Conditions>[]): this;
    private _buildIndexFor;
    can(...args: CanParameters<A>): boolean;
    relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null;
    possibleRulesFor(...args: CanParameters<A, false>): Rule<A, Conditions>[];
    private _mergeRulesFor;
    rulesFor(...args: CanParameters<A>): Rule<A, Conditions>[];
    cannot(...args: CanParameters<A>): boolean;
    on<T extends keyof EventsMap<this>>(event: T, handler: EventHandler<EventsMap<this>[T]>): Unsubscribe;
    private _emit;
}
export {};
